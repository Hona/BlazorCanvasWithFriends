@page "/canvas"
@rendermode InteractiveWebAssembly

@using System.Drawing
@using BlazorWithFriends.Shared.Models
@using Excubo.Blazor.Canvas

@inject CanvasClient CanvasClient
@inject IJSRuntime JsRuntime

<PageTitle>
    Canvas
</PageTitle>

<Canvas @ref="helper_canvas" 
        id="@CanvasId"
        width="@(_canvasWidth + "px")" 
        height="@(_canvasHeight + "px")" 
        style="width: 100%; height: 100%"
        @onmousedown="HandleMouseDown" 
        @onmousemove="HandleMouseMove"
        @onmouseup="HandleMouseUp" />

<p>
    IsConnected : @CanvasClient.IsConnected
</p>

@code {
    
    private int _canvasWidth = 800;
    private int _canvasHeight = 600;
    private const string CanvasId = "canvaswithfriends";

    protected override async Task OnInitializedAsync()
    {
        CanvasClient.OnDrawLine = EventCallback.Factory.Create<(Point2D, Point2D)>(
            this, HandleDrawLine);

        await CanvasClient.InitializeAsync();
        
        await base.OnInitializedAsync();
    }

    // Canvas
    private Point2D? _from;
    private Point2D? _to;

    private record CanvasBounds(double Left, double Top, double Width, double Height);
    private record BrowserScroll(double X, double Y);
    
    private async Task<Point2D> GetMousePosition(MouseEventArgs e)
    {
        var element = await JsRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", CanvasId);
        var rect = await element.InvokeAsync<CanvasBounds>("getBoundingClientRect");
    
        var scroll = await JsRuntime.InvokeAsync<BrowserScroll>("getScroll");
    
        // Calculate the mouse position within the canvas by taking the mouse position relative to the viewport (e.ClientX, e.ClientY),
        // subtracting the canvas's position relative to the viewport (rect.Left + scroll.X, rect.Top + scroll.Y),
        // and then scaling these values according to the actual size of the canvas in the document.
        var x = e.ClientX - rect.Left + scroll.X;
        var y = e.ClientY - rect.Top + scroll.Y;
    
        // Adjust for any scaling if the canvas is styled differently from its intrinsic size.
        var scaleX = _canvasWidth / rect.Width;
        var scaleY = _canvasHeight / rect.Height;
    
        x *= scaleX;
        y *= scaleY;
    
        return new Point2D((int)x, (int)y);
    }

    
    private async Task HandleMouseDown(MouseEventArgs e)
    {
        var point = await GetMousePosition(e);
        _from = point;
    }
    
    private async Task HandleMouseUp(MouseEventArgs e)
    {
        var point = await GetMousePosition(e);
        _to = point;
        
        if (_from is not null && _to is not null)
        {
            await CanvasClient.Hub?.DrawLine(_from, _to);
            
            _from = null;
            _to = null;
        }
    }
    
    private DateTime _lastUpdateSent = DateTime.MinValue;

    private const double TicksPerSecond = 64; 
    
    private TimeSpan _throttleDuration = TimeSpan.FromMilliseconds(1000 / TicksPerSecond);

    
    private async Task HandleMouseMove(MouseEventArgs e)
    {
        if (_from is not null)
        {
            var now = DateTime.Now;
            if ((now - _lastUpdateSent) < _throttleDuration) return; // Throttle the method call

            var point = await GetMousePosition(e);
            _to = point;
            
            if (_from is not null && _to is not null)
            {
                await CanvasClient.Hub?.DrawLine(_from, _to);
                
                _from = _to;
                _lastUpdateSent = now;
            }
        }
    }
    
    private Canvas helper_canvas;
    protected override async Task OnAfterRenderAsync(bool first_render)
    {
        if (first_render)
        {
            await using var ctx1 = await helper_canvas.GetContext2DAsync();
            // Black background
            await ctx1.FillStyleAsync("#000");
            await ctx1.FillRectAsync(0, 0, _canvasWidth, _canvasHeight);

            await CanvasClient.Hub?.RequestState();
        }
    }

    private async Task HandleDrawLine((Point2D from, Point2D to) args)
    {
        Console.WriteLine("DrawLine {0} {1}", args.from, args.to);
        var (from, to) = args;
        
        await using var ctx = await helper_canvas.GetContext2DAsync();
        await ctx.StrokeStyleAsync("#fff");
        await ctx.BeginPathAsync();
        await ctx.MoveToAsync(from.X, from.Y);
        await ctx.LineToAsync(to.X, to.Y);
        await ctx.StrokeAsync();
    }
}